{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Client/","text":"Client Functions Initialize: init() Parameters () Description: Initializes the client. This includes initializing any client modules that contain a init() function OnInput: onInput() Parameters () Description: This is a function the client has that is binded to the RenderStep Lifetime Event. This is where input is updated for the client, this helps with overriding core movement that is unneeded, such as jumping. OnPreRender: onPreRender() Parameters dt number Description: This is a function used in the client that is binded to the PreRender Lifetime Event. This is where visuals are calculated such as camera position and rotation, and User Interface.","title":"Main"},{"location":"Client/#client","text":"","title":"Client"},{"location":"Client/#functions","text":"","title":"Functions"},{"location":"Client/#initialize-init","text":"","title":"Initialize: init()"},{"location":"Client/#parameters","text":"()","title":"Parameters"},{"location":"Client/#description","text":"Initializes the client. This includes initializing any client modules that contain a init() function","title":"Description:"},{"location":"Client/#oninput-oninput","text":"","title":"OnInput: onInput()"},{"location":"Client/#parameters_1","text":"()","title":"Parameters"},{"location":"Client/#description_1","text":"This is a function the client has that is binded to the RenderStep Lifetime Event. This is where input is updated for the client, this helps with overriding core movement that is unneeded, such as jumping.","title":"Description:"},{"location":"Client/#onprerender-onprerender","text":"","title":"OnPreRender: onPreRender()"},{"location":"Client/#parameters_2","text":"dt number","title":"Parameters"},{"location":"Client/#description_2","text":"This is a function used in the client that is binded to the PreRender Lifetime Event. This is where visuals are calculated such as camera position and rotation, and User Interface.","title":"Description:"},{"location":"Client/Audio/","text":"Audio Properties MaxEmitters: number Description: MaxEmitters is used to create a limit to the size of the cache of emitters used in the audio module. Functions Init: init() Parameters () Description: This is the initialization function of the Audio Module. In the initialization, a Sound Origin is made to house the cache of sound emitters. Sounds from the library are also loaded into the game to reduce chances of the lack of audio or SFX in realtime gameplay. OnEmissionEvent: onEmissionEvent() Parameters key from props string Vector3? SoundProperties Description: Emits an Audio whenever the bindable event: EmitAudio is fired on the client. Given the key, the sound will play at a given location with the given and supported properties found in a Sound Instance, such as Volume and Distance . If a given distance is not found, then the audio will be played via game.SoundService:PlayLocalSound() GetSFX: getSFX() Parameters key string Description: This is a local function used to return a entry inside the audio module's Library module that holds all keys and SoundID 's.","title":"Audio"},{"location":"Client/Audio/#audio","text":"","title":"Audio"},{"location":"Client/Audio/#properties","text":"","title":"Properties"},{"location":"Client/Audio/#maxemitters-number","text":"","title":"MaxEmitters: number"},{"location":"Client/Audio/#description","text":"MaxEmitters is used to create a limit to the size of the cache of emitters used in the audio module.","title":"Description:"},{"location":"Client/Audio/#functions","text":"","title":"Functions"},{"location":"Client/Audio/#init-init","text":"","title":"Init: init()"},{"location":"Client/Audio/#parameters","text":"()","title":"Parameters"},{"location":"Client/Audio/#description_1","text":"This is the initialization function of the Audio Module. In the initialization, a Sound Origin is made to house the cache of sound emitters. Sounds from the library are also loaded into the game to reduce chances of the lack of audio or SFX in realtime gameplay.","title":"Description:"},{"location":"Client/Audio/#onemissionevent-onemissionevent","text":"","title":"OnEmissionEvent: onEmissionEvent()"},{"location":"Client/Audio/#parameters_1","text":"key from props string Vector3? SoundProperties","title":"Parameters"},{"location":"Client/Audio/#description_2","text":"Emits an Audio whenever the bindable event: EmitAudio is fired on the client. Given the key, the sound will play at a given location with the given and supported properties found in a Sound Instance, such as Volume and Distance . If a given distance is not found, then the audio will be played via game.SoundService:PlayLocalSound()","title":"Description:"},{"location":"Client/Audio/#getsfx-getsfx","text":"","title":"GetSFX: getSFX()"},{"location":"Client/Audio/#parameters_2","text":"key string","title":"Parameters"},{"location":"Client/Audio/#description_3","text":"This is a local function used to return a entry inside the audio module's Library module that holds all keys and SoundID 's.","title":"Description:"},{"location":"Client/Camera/","text":"Camera Properties CamMist: BasePart Description: CamMist is used to create a fog around the character on the client. This is rarely used unless in gameplay testing but it is functional. CurrentRotation: number Description: CurrentRotation is used to keep track of the current rotation of the camera focused along a character. Highlight: Highlight Description: A highlight used to show the character if the line of sight is obstructed between the camera and character. Functions Init: Tnit() Parameters camera offset FOV Camera number number Description Initializes the camera module by creating the highlight instance and raycast parameters for the line of sight from the character subject. OnInput: onEvent() Parameters name amount string number Description: This function is used as a callback to when a camera input is recieved and to change the camera rotation. OnCharacterAdded: OnCharacterAdded() Parameters character Model Description: Fired whenever a character is passed to serve as the camera's subject. This could be either the player has gotten their character, or they are spectating another character. SetCameraAnchor: SetCameraAnchor() Parameters AnchorPart BasePart Description: Used to set the camera's CFrame equal to the CFrame of the given AnchorPart . Used in features of the game that require a different perspective. OnCharacterRemoved: OnCharacterRemoved() Parameters () Description: Stops the camera from rendering without a character subject. OnCameraModeChanged: OnCameraModeChanged() Parameters mode number Description: Sets the camera's mode to the mode provided. Camera Modes: 1 - Isometric Character View 2 - AnchorPart Static View 3 - None (Cutscene View???) OnSubjectChanged: OnSubjectChanged Parameters subject BasePart OR Model Description: Used to determine if the given subject is a character or a anchored part. If the subject is a character, it will set it as a subject. Otherwise it will act as an anchored part. SetRotation: SetRotation() Parameters amount number Description: Loops and iterates through the rotation values used for the camera's isometric subject view. SetMistEnabled: SetMistEnabled() Parameters enabled boolean Description: Used to enable and disable the camera mist. Update: Update() Parameters dt number Description: Updates the camera every frame inside the client's PreRender Lifetime Event.","title":"Camera"},{"location":"Client/Camera/#camera","text":"","title":"Camera"},{"location":"Client/Camera/#properties","text":"","title":"Properties"},{"location":"Client/Camera/#cammist-basepart","text":"","title":"CamMist: BasePart"},{"location":"Client/Camera/#description","text":"CamMist is used to create a fog around the character on the client. This is rarely used unless in gameplay testing but it is functional.","title":"Description:"},{"location":"Client/Camera/#currentrotation-number","text":"","title":"CurrentRotation: number"},{"location":"Client/Camera/#description_1","text":"CurrentRotation is used to keep track of the current rotation of the camera focused along a character.","title":"Description:"},{"location":"Client/Camera/#highlight-highlight","text":"","title":"Highlight: Highlight"},{"location":"Client/Camera/#description_2","text":"A highlight used to show the character if the line of sight is obstructed between the camera and character.","title":"Description:"},{"location":"Client/Camera/#functions","text":"","title":"Functions"},{"location":"Client/Camera/#init-tnit","text":"","title":"Init: Tnit()"},{"location":"Client/Camera/#parameters","text":"camera offset FOV Camera number number","title":"Parameters"},{"location":"Client/Camera/#description_3","text":"Initializes the camera module by creating the highlight instance and raycast parameters for the line of sight from the character subject.","title":"Description"},{"location":"Client/Camera/#oninput-onevent","text":"","title":"OnInput: onEvent()"},{"location":"Client/Camera/#parameters_1","text":"name amount string number","title":"Parameters"},{"location":"Client/Camera/#description_4","text":"This function is used as a callback to when a camera input is recieved and to change the camera rotation.","title":"Description:"},{"location":"Client/Camera/#oncharacteradded-oncharacteradded","text":"","title":"OnCharacterAdded: OnCharacterAdded()"},{"location":"Client/Camera/#parameters_2","text":"character Model","title":"Parameters"},{"location":"Client/Camera/#description_5","text":"Fired whenever a character is passed to serve as the camera's subject. This could be either the player has gotten their character, or they are spectating another character.","title":"Description:"},{"location":"Client/Camera/#setcameraanchor-setcameraanchor","text":"","title":"SetCameraAnchor: SetCameraAnchor()"},{"location":"Client/Camera/#parameters_3","text":"AnchorPart BasePart","title":"Parameters"},{"location":"Client/Camera/#description_6","text":"Used to set the camera's CFrame equal to the CFrame of the given AnchorPart . Used in features of the game that require a different perspective.","title":"Description:"},{"location":"Client/Camera/#oncharacterremoved-oncharacterremoved","text":"","title":"OnCharacterRemoved: OnCharacterRemoved()"},{"location":"Client/Camera/#parameters_4","text":"()","title":"Parameters"},{"location":"Client/Camera/#description_7","text":"Stops the camera from rendering without a character subject.","title":"Description:"},{"location":"Client/Camera/#oncameramodechanged-oncameramodechanged","text":"","title":"OnCameraModeChanged: OnCameraModeChanged()"},{"location":"Client/Camera/#parameters_5","text":"mode number","title":"Parameters"},{"location":"Client/Camera/#description_8","text":"Sets the camera's mode to the mode provided.","title":"Description:"},{"location":"Client/Camera/#camera-modes","text":"1 - Isometric Character View 2 - AnchorPart Static View 3 - None (Cutscene View???)","title":"Camera Modes:"},{"location":"Client/Camera/#onsubjectchanged-onsubjectchanged","text":"","title":"OnSubjectChanged: OnSubjectChanged"},{"location":"Client/Camera/#parameters_6","text":"subject BasePart OR Model","title":"Parameters"},{"location":"Client/Camera/#description_9","text":"Used to determine if the given subject is a character or a anchored part. If the subject is a character, it will set it as a subject. Otherwise it will act as an anchored part.","title":"Description:"},{"location":"Client/Camera/#setrotation-setrotation","text":"","title":"SetRotation: SetRotation()"},{"location":"Client/Camera/#parameters_7","text":"amount number","title":"Parameters"},{"location":"Client/Camera/#description_10","text":"Loops and iterates through the rotation values used for the camera's isometric subject view.","title":"Description:"},{"location":"Client/Camera/#setmistenabled-setmistenabled","text":"","title":"SetMistEnabled: SetMistEnabled()"},{"location":"Client/Camera/#parameters_8","text":"enabled boolean","title":"Parameters"},{"location":"Client/Camera/#description_11","text":"Used to enable and disable the camera mist.","title":"Description:"},{"location":"Client/Camera/#update-update","text":"","title":"Update: Update()"},{"location":"Client/Camera/#parameters_9","text":"dt number","title":"Parameters"},{"location":"Client/Camera/#description_12","text":"Updates the camera every frame inside the client's PreRender Lifetime Event.","title":"Description:"},{"location":"Client/Visuals/","text":"Visuals Work In Progress Refactoring has been planned, so expect this to not get created until the refactor is finished!","title":"Visuals"},{"location":"Client/Visuals/#visuals","text":"","title":"Visuals"},{"location":"Client/Visuals/#work-in-progress","text":"Refactoring has been planned, so expect this to not get created until the refactor is finished!","title":"Work In Progress"},{"location":"Client/Camera/CameraController/","text":"CameraController Overview Manages the client's active camera mode in the game, allowing for switching between multiple camera behaviors dynamically based on remote events. Summary The CameraController listens for camera mode change events from the server. It initializes and manages instances of different camera modes, switching between them when necessary. Each camera mode must implement the Init , Update , and Stop methods. Types CameraController : Object managing the active camera mode and switching logic. CameraMode (from Shared): Represents a camera behavior. Expected to have Init, Update, and Stop methods, and a kind property of type CameraModeName. CameraModeName (from Shared): Enum-like string identifying the type of a camera mode. Functions CameraController.new(): CameraController Creates and returns a new instance of CameraController CameraController:SetMode(mode: CameraMode): () Switches the currently active camera mode to the given mode . If the mode is already active, no action is taken If a different mode is active, it is stopped before switching If the mode is not previously tracked, it is added to the controller's list of cameras CameraController:Start(): () Begins listening for server events ( CameraModeChanged ) to update the active camera mode. Also binds the active camera mode's Update method to RunService.PreRender","title":"CameraController"},{"location":"Client/Camera/CameraController/#cameracontroller","text":"","title":"CameraController"},{"location":"Client/Camera/CameraController/#overview","text":"Manages the client's active camera mode in the game, allowing for switching between multiple camera behaviors dynamically based on remote events.","title":"Overview"},{"location":"Client/Camera/CameraController/#summary","text":"The CameraController listens for camera mode change events from the server. It initializes and manages instances of different camera modes, switching between them when necessary. Each camera mode must implement the Init , Update , and Stop methods.","title":"Summary"},{"location":"Client/Camera/CameraController/#types","text":"CameraController : Object managing the active camera mode and switching logic. CameraMode (from Shared): Represents a camera behavior. Expected to have Init, Update, and Stop methods, and a kind property of type CameraModeName. CameraModeName (from Shared): Enum-like string identifying the type of a camera mode.","title":"Types"},{"location":"Client/Camera/CameraController/#functions","text":"","title":"Functions"},{"location":"Client/Camera/CameraController/#cameracontrollernew-cameracontroller","text":"Creates and returns a new instance of CameraController","title":"CameraController.new(): CameraController"},{"location":"Client/Camera/CameraController/#cameracontrollersetmodemode-cameramode","text":"Switches the currently active camera mode to the given mode . If the mode is already active, no action is taken If a different mode is active, it is stopped before switching If the mode is not previously tracked, it is added to the controller's list of cameras","title":"CameraController:SetMode(mode: CameraMode): ()"},{"location":"Client/Camera/CameraController/#cameracontrollerstart","text":"Begins listening for server events ( CameraModeChanged ) to update the active camera mode. Also binds the active camera mode's Update method to RunService.PreRender","title":"CameraController:Start(): ()"},{"location":"Client/Interface/","text":"","title":"Interface"},{"location":"Client/Interface/ObjectiveHandler/","text":"ObjectiveHandler Functions OnInputFired() Parmeters model: Model The model of the objective with the proximity prompt. interface: ScreenGui The main client GUI used to hold/switch between different UI states. Description","title":"ObjectiveHandler"},{"location":"Client/Interface/ObjectiveHandler/#objectivehandler","text":"","title":"ObjectiveHandler"},{"location":"Client/Interface/ObjectiveHandler/#functions","text":"","title":"Functions"},{"location":"Client/Interface/ObjectiveHandler/#oninputfired","text":"","title":"OnInputFired()"},{"location":"Client/Interface/ObjectiveHandler/#parmeters","text":"model: Model The model of the objective with the proximity prompt. interface: ScreenGui The main client GUI used to hold/switch between different UI states.","title":"Parmeters"},{"location":"Client/Interface/ObjectiveHandler/#description","text":"","title":"Description"},{"location":"Events/ObjectiveEvents/","text":"Objective Events Prompt Type: RemoteEvent Location: ReplicatedStorage.Events.Prompt Description Prompt is currently used to route all game objectives proximity prompts to a central handler, Client.Interface.ObjectiveHandler.OnInputFired(model: Model, interface: ScreenGui) Usage \ud83d\udd01 Listening (Client or Server) local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local MyCustomEvent = ReplicatedStorage:WaitForChild(\"Events\"):WaitForChild(\"MyCustomEvent\") MyCustomEvent.Event:Connect(function(player) print(player.Name .. \" completed the puzzle!\") -- Add client/server-side logic here end)","title":"Objective Events"},{"location":"Events/ObjectiveEvents/#objective-events","text":"","title":"Objective Events"},{"location":"Events/ObjectiveEvents/#prompt","text":"Type: RemoteEvent Location: ReplicatedStorage.Events.Prompt","title":"Prompt"},{"location":"Events/ObjectiveEvents/#description","text":"Prompt is currently used to route all game objectives proximity prompts to a central handler, Client.Interface.ObjectiveHandler.OnInputFired(model: Model, interface: ScreenGui)","title":"Description"},{"location":"Events/ObjectiveEvents/#usage","text":"","title":"Usage"},{"location":"Events/ObjectiveEvents/#listening-client-or-server","text":"local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local MyCustomEvent = ReplicatedStorage:WaitForChild(\"Events\"):WaitForChild(\"MyCustomEvent\") MyCustomEvent.Event:Connect(function(player) print(player.Name .. \" completed the puzzle!\") -- Add client/server-side logic here end)","title":"\ud83d\udd01 Listening (Client or Server)"},{"location":"Server/","text":"Server Functions Update() Parmeters t: number The duration (in seconds) that RunService has been running for. dt: number The time (in seconds) that has elapsed since the previous frame. Description Called every RunService .Stepped event. Calls Collections Update() function","title":"Main"},{"location":"Server/#server","text":"","title":"Server"},{"location":"Server/#functions","text":"","title":"Functions"},{"location":"Server/#update","text":"","title":"Update()"},{"location":"Server/#parmeters","text":"t: number The duration (in seconds) that RunService has been running for. dt: number The time (in seconds) that has elapsed since the previous frame.","title":"Parmeters"},{"location":"Server/#description","text":"Called every RunService .Stepped event. Calls Collections Update() function","title":"Description"},{"location":"Server/Collections/","text":"Collections Overview The Collections Module under Server is used to handle initializing game objects. Functions InitializeObjectives() Parameters () Description Loops through all objects tagged \"Objective\" and calls InitializeModel(model)","title":"Collections"},{"location":"Server/Collections/#collections","text":"","title":"Collections"},{"location":"Server/Collections/#overview","text":"The Collections Module under Server is used to handle initializing game objects.","title":"Overview"},{"location":"Server/Collections/#functions","text":"","title":"Functions"},{"location":"Server/Collections/#initializeobjectives","text":"","title":"InitializeObjectives()"},{"location":"Server/Collections/#parameters","text":"()","title":"Parameters"},{"location":"Server/Collections/#description","text":"Loops through all objects tagged \"Objective\" and calls InitializeModel(model)","title":"Description"},{"location":"Server/LaserEmitter/","text":"Laser Emitter Overview Enables the behavior of dynamic lasers in the laser objective.","title":"LaserEmitter"},{"location":"Server/LaserEmitter/#laser-emitter","text":"","title":"Laser Emitter"},{"location":"Server/LaserEmitter/#overview","text":"Enables the behavior of dynamic lasers in the laser objective.","title":"Overview"},{"location":"Server/Generation/","text":"","title":"Main"},{"location":"Server/Generation/TileMaskHelper/","text":"TileMaskHelper Overview The TileMaskHelper module is responsible for calculating and managing tile bitmask values for cells in our grid-based map. It determines the connection state of each walkable tile by evaluating its neighbors in four cardinal directions \u2014 North, West, East, and South \u2014 and encodes this connectivity using a directional bitmask. This bitmask is used for purposes such as: 1) Dynamically determining tile appearances (auto-tiling) 2) Broadcasting changes to listeners via events Functions updateCells(map: Grid, cells: { Cell }) Parmeters map: Grid The Grid in which the updates are taking place (this should be the global map Grid). cells: { Cell } A list of cells that should be updated. Description Recalculates the tile mask of each cell, and fires TileMaskUpdateDoneEvent when all have been recalculated.","title":"TileMaskHelper"},{"location":"Server/Generation/TileMaskHelper/#tilemaskhelper","text":"","title":"TileMaskHelper"},{"location":"Server/Generation/TileMaskHelper/#overview","text":"The TileMaskHelper module is responsible for calculating and managing tile bitmask values for cells in our grid-based map. It determines the connection state of each walkable tile by evaluating its neighbors in four cardinal directions \u2014 North, West, East, and South \u2014 and encodes this connectivity using a directional bitmask. This bitmask is used for purposes such as: 1) Dynamically determining tile appearances (auto-tiling) 2) Broadcasting changes to listeners via events","title":"Overview"},{"location":"Server/Generation/TileMaskHelper/#functions","text":"","title":"Functions"},{"location":"Server/Generation/TileMaskHelper/#updatecellsmap-grid-cells-cell","text":"","title":"updateCells(map: Grid, cells: { Cell })"},{"location":"Server/Generation/TileMaskHelper/#parmeters","text":"map: Grid The Grid in which the updates are taking place (this should be the global map Grid). cells: { Cell } A list of cells that should be updated.","title":"Parmeters"},{"location":"Server/Generation/TileMaskHelper/#description","text":"Recalculates the tile mask of each cell, and fires TileMaskUpdateDoneEvent when all have been recalculated.","title":"Description"},{"location":"Server/Objectives/ObjectiveUtil/","text":"","title":"ObjectiveUtil"},{"location":"Server/Objectives/LaserObjective/","text":"LaserObjective","title":"LaserObjective"},{"location":"Server/Objectives/LaserObjective/#laserobjective","text":"","title":"LaserObjective"},{"location":"Server/Objectives/LaserObjective/LaserUtil/","text":"Laser Util","title":"LaserUtil"},{"location":"Server/Objectives/LaserObjective/LaserUtil/#laser-util","text":"","title":"Laser Util"},{"location":"Server/Objectives/LaserObjective/MirrorSolver/","text":"MirrorSolver Overview Responsible for generating a solution to a laser objective puzzle by placing mirrors throughout the room.","title":"MirrorSolver"},{"location":"Server/Objectives/LaserObjective/MirrorSolver/#mirrorsolver","text":"","title":"MirrorSolver"},{"location":"Server/Objectives/LaserObjective/MirrorSolver/#overview","text":"Responsible for generating a solution to a laser objective puzzle by placing mirrors throughout the room.","title":"Overview"},{"location":"Workflows/CreatingACamera/","text":"Creating a Camera","title":"Creating a Camera"},{"location":"Workflows/CreatingACamera/#creating-a-camera","text":"","title":"Creating a Camera"},{"location":"Workflows/ObjectiveUtils/","text":"Objective Utilities (GUI) About Objective Utilities on the Client are modules with functions that help with the logic of the ObjectiveHandler inside the Interface Module. These can be anything, but I have used them to act as similar to UIHandlers in a sense that they handle the specific types of objectives and their GUI Instances.","title":"ObjectiveUtils"},{"location":"Workflows/ObjectiveUtils/#objective-utilities-gui","text":"","title":"Objective Utilities (GUI)"},{"location":"Workflows/ObjectiveUtils/#about","text":"Objective Utilities on the Client are modules with functions that help with the logic of the ObjectiveHandler inside the Interface Module. These can be anything, but I have used them to act as similar to UIHandlers in a sense that they handle the specific types of objectives and their GUI Instances.","title":"About"},{"location":"Workflows/Objectives/","text":"Objectives Function Call Sequence This section describes the sequence of function calls that manage objectives. Below is the flow of the functions in the sequence: Collections.InitializeMapObjects() - Collections.InitializeObjectives() - Loops through all objects tagged \"Objective\" and calls ObjectiveUtil.InitializeModel(model) ObjectiveUtil.InitializeModel(model: Model ) - Finds the model's proximity prompt and hooks up its .Triggered event handler. Inside the handler, fires Prompt client event. This causes #4 to run: Client.Interface.ObjectiveHandler.OnInputFired(model: Model, interface: ScreenGui)","title":"Objectives"},{"location":"Workflows/Objectives/#objectives","text":"","title":"Objectives"},{"location":"Workflows/Objectives/#function-call-sequence","text":"This section describes the sequence of function calls that manage objectives. Below is the flow of the functions in the sequence: Collections.InitializeMapObjects() - Collections.InitializeObjectives() - Loops through all objects tagged \"Objective\" and calls ObjectiveUtil.InitializeModel(model) ObjectiveUtil.InitializeModel(model: Model ) - Finds the model's proximity prompt and hooks up its .Triggered event handler. Inside the handler, fires Prompt client event. This causes #4 to run: Client.Interface.ObjectiveHandler.OnInputFired(model: Model, interface: ScreenGui)","title":"Function Call Sequence"},{"location":"Workflows/UIHandlers/","text":"Interface Handlers UIHandlers is a psuedo-class module that initializes a frame or other UI components that are passed when intitializing Handler. Composition UIHandlers are puesdo-classes, meaning that they behave as a collection of helper functions that are for specific instances that you pass as a parameter. These are very versitile for us in order to manage pieces of GUI without most of the code going inside our main Interface Module on the client. But UIHandlers are composed of atleast two functions. init() and cleanup() . As labeled, init() will initialize the ui element you want and cleanup() will stop the ui element from updating and will disconnect any connections created. To keep track of connections inside your init() function, handlers tend to keep an array inside the module. Inserting your connections into a array for later, easier cleanup of connections is a good practice to save unnecessary updates to non-visible interface. Functions Init: init() Parameters frame any GuiBase ... Description: A base function to initialize a Interface Handler, usually most init functions, you will just want your specific GUI instance you want to program and any necessary information you want afterwards. Cleanup: cleanup() Parameters frame any GuiBase ... Description: The base function used to hide, disconnect, and stop updating the given GUI instance. You could add any other necessary information as well if you'd like.","title":"Handlers"},{"location":"Workflows/UIHandlers/#interface-handlers","text":"UIHandlers is a psuedo-class module that initializes a frame or other UI components that are passed when intitializing Handler.","title":"Interface Handlers"},{"location":"Workflows/UIHandlers/#composition","text":"UIHandlers are puesdo-classes, meaning that they behave as a collection of helper functions that are for specific instances that you pass as a parameter. These are very versitile for us in order to manage pieces of GUI without most of the code going inside our main Interface Module on the client. But UIHandlers are composed of atleast two functions. init() and cleanup() . As labeled, init() will initialize the ui element you want and cleanup() will stop the ui element from updating and will disconnect any connections created. To keep track of connections inside your init() function, handlers tend to keep an array inside the module. Inserting your connections into a array for later, easier cleanup of connections is a good practice to save unnecessary updates to non-visible interface.","title":"Composition"},{"location":"Workflows/UIHandlers/#functions","text":"","title":"Functions"},{"location":"Workflows/UIHandlers/#init-init","text":"","title":"Init: init()"},{"location":"Workflows/UIHandlers/#parameters","text":"frame any GuiBase ...","title":"Parameters"},{"location":"Workflows/UIHandlers/#description","text":"A base function to initialize a Interface Handler, usually most init functions, you will just want your specific GUI instance you want to program and any necessary information you want afterwards.","title":"Description:"},{"location":"Workflows/UIHandlers/#cleanup-cleanup","text":"","title":"Cleanup: cleanup()"},{"location":"Workflows/UIHandlers/#parameters_1","text":"frame any GuiBase ...","title":"Parameters"},{"location":"Workflows/UIHandlers/#description_1","text":"The base function used to hide, disconnect, and stop updating the given GUI instance. You could add any other necessary information as well if you'd like.","title":"Description:"}]}